# 1-1 CASE式のススメ
## P15 CHECK制約で複数の列の条件関係を定義する

        CONSTRAINT check_salary CHECK
                   (CASE WHEN SEX = '2'
                         THEN CASE WHEN salary  <= 200000
                                   THEN 1 ELSE 0 END
                         ELSE 1 END = 1)

- これは命題論理で条件法（conditional）と呼ばれる論理式で、形式的に書けば『P -> Q』となる。
&emsp;&emsp;
<BR><BR>

        CONSTRAINT check_salary CHECK
                   (SEX = '2' AND salary  <= 200000)
- 論理積(logical conjunction)とは『PかつQ』を意味する論理式で形式的に書けば『P ∧ Q』となる。(ANDとよく表す)

*論理積のCHECK制約を付けると、この会社は男性を雇用できなくなる。条件法であれば、男性も働ける*
<BR><BR>

## p19 主键的替换
        update sometable set p_key = 'd' where p_key = 'a';  
        update sometable set p_key = 'a' where p_key = 'b';  
        update sometable set p_key = 'b' where p_key = 'd';
<BR><BR>

**用case**  
        
        update sometable set p_key case   
        when p_key = 'a' then 'b'  
        when p_key = 'b' then 'a'  
        else p_key end where p_key in ('a'，'b');
<BR><BR>

## p20 テーブル同士のマッチング
    select course_name,
    case when course_id in (select course_id from openmonth where month = 200706) then 'o' else 'x' end as '6月' ,
    case when course_id in (select course_id from openmonth where month = 200707) then 'o' else 'x' end as '7月' ,
    case when course_id in (select course_id from openmonth where month = 200708) then 'o' else 'x' end as '8月' from course;
<BR><BR>

## まとめ
CASE式は実行時には評価されて一つの値に定まるし（だから集約関数の中でに書ける）、式だから、SELECTにもGROUP　BY にもWHEREにもORDER　BYにも書ける。
CASE式は列名や定数を書ける場所には常に書くことができる。
<BR><BR>

## 演習問題1-1

        select g.key,
            case when case when x < y then y else x end < z 
                then z 
                else case when x < y then y else x end 
             end as greater from G;
<BR><BR>             

# 1-2 自己結合の使い方 
## p32 重複行を削除する
        delete from product p1
         where exists(select *
                       from product p2
                       where p1.name = p2.name
                         and p1.price = p2.price
                         and p1.rowid < p2.rowid);
<BR><BR>             

## p34 部分的に不一致なキーの検索
        select distinct a1.name,a1.address
          from address a1,address a2
         where a1.family_id = a2.family_id
           and a1.address <> a2.address;

    输出价格一样的所有商品
        select distinct a1.goods_name,a1.price
          from goods a1,goods a2
         where a1.price = a2.price
           and a1.goods_name <> a2.goods_name;
<BR><BR> 

## p36　ランキング
### OLAP関数の利用

    select name,price,
           rank() over (order by price DESC) as rank_1,
           DENSE_rank() over (order by price DESC) as rank_2
    from products;       


| name  | price  |	rank_1 | rank_2 |
|:--------| :---------:|--------:|--------:|
| みかん | 100 |1|1|
|スイカ| 80|2|2|
|りんご| 50|3|3|
|ぶどう| 50|3|3|
|バナナ| 50|3|3|
|レモン| 30|6|4|
<BR><BR> 

    select p1.name,p1.price,
           (select count(p2.price)
           from product p2
           where p2.price > p1.price) + 1 as rank_1
    from product p1;       

<BR><BR>

## まとめ
自己結合で使用する結合キーは、なるべく主キーを使うか、あるいはインデックスを作成しておくことをススメ
1. 自己結合は非等値結合と組み合わせで使うのが基本
2. GROUP　BYと組み合わせると、再帰的集合を作ることができる
3. 本当に異なるテーブルを結合していると考えると理解しやすい
4. テーブルを行を集合に見立てて、集合指向的な発想で考える。
5. 処理コストが高くなりがちのため、なるべく結合キーにインデックスを付けして使う。
<BR><BR>

# 1-3 3値論理とNULL
## P15 以下の式全部unknowに評価される
    = NULL
    > NULL
    < NULL
    <> NULL
    NULL = NULL
### NULLが値でも変数でもない    
### ANDの場合は:false > unknown > true
### ORの場合は:true > unknown > false
### 1. 比較述語とNULL　その1
    select *
    from student
    where age = 20
    or age <> 20
    or age is null;
### 2. 比較述語とNULL　その2
    case WHEN co1_1 = 1 then 'o'
         WHEN co1_1 is null then 'x' 
    end
### 3. NOT IN と NOT EXISTSは同値ではない
正しい結果
    select * 
    from class_A A
    where not exists (select * 
                      from class_B B
                      where A.age = B.age
                      and B.city = 'tokyo');

### 4. 限定述語とNULL　
#### Bクラスの東京在住のよりも若いAクラスの生徒を選択する
    select *
      from class_A
      where age < null (select age
                          from class_B
                         where city = 'tokyo');

### 5. 限定述語と極値関数は同値ではない
#### Bクラスの東京在住の最も1も若い生徒より若いAクラスの生徒を選択する　
    select * 
      from class_A
     where age <(select MIN(age)
                   from class_B
                  where city = 'tokyo'); 

### 6. 集約関数とNULL
 #### 東京在住の生徒の平均年齢より若いAクラスの生徒を選択する                 
    select *
      from class_A
    where age <(select MIN(age)
                   from class_B
                  where city = 'tokyo'); 
### 東京在住の生徒がない場合、AVG関数はNULLを返す。
### そのため外側のWHEREが常にunknownになり、一行も選択しない
<BR><BR>

# 1-3 HAVINGの力
## HAVINGでサブクエリ　最頻値を求める
###  最頻値を求める　その1　ALL述語の利用
    select income,count(*) as cnt
      from graduates
     group by income
    having count(*) >= ALL( select count(*)
                              from graduates
                             group by income);

| income | cnt |
|:--------| :---------:|
| 10,000 | 3 |
|20,000| 3|
<BR>

###  最頻値を求める　その2　極値関数の利用
    select income,count(*) as cnt
      from graduates
     group by income
    having count(*) >= ( select max(cnt)
                              from (select count(*) as cnt
                                      from graduates
                                     group by income)tmp);
<BR>

## NULLを含まない集合を探す
### 提出日にNULL含まない学部を選択する　その1COUNT関数の利用
    select dpt
      from students
     group by dpt
    having count(*) = count(sbmt_table);

### 提出日にNULL含まない学部を選択する　その2CASEの利用
    select dpt
      from students
     group by dpt
    having count(*) = sum(case when sbmt_date is not null
                               then 1
                               else 0 end);

## 関係除算でバスケット解析
    select si.shop
      from shopitem si,item i
     where si.item = i.item
     group by si.shop
    having count(si.item) = (select count(item) from items);

### count(i.item)はもはや3とは限らない
    select si.shop,count(si.item),count(i.item)
      from shopitem si,item i 
     where si.item = i.item
     group by si.shop;

| shop | count(si.item) | count(i.item) |
|:--------| :---------:| :---------:|
| 仙台 | 3 |3 |
|東京| 3|3|
|大阪|2|2|

## 厳密な関係除算: 外部結合とCOUNT関数の利用
select si.shop
  from shopitems si left join item i
    on si.item = i.item
 group by si.shop
having count(si.item) = (select count(item) from items)  --条件1
   and count(i.item) = (select count(item) from items);  --条件2
