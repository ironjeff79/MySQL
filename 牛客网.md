# 1 修改表
### 请在用户信息表，字段level的后面增加一列最多可保存15个汉字的字段school；并将表中job列名改为profession，同时varchar字段长度变为10；achievement的默认值设置为0。

    alter table user_info add school varchar(15) after `level`;
    alter table user_info change job profession varchar(10);
    alter table user_info modify achievement int(11) default 0;



**增加列在某列之后**
alter table 增加的表格 add 增加列的名称 数据类型 位置(after level 在level 之后)

**更换列的名称及数据类型**
alter table user_info change 原列名 修改列名 修改数据类型

**更改数据类型**
alter table 表名 modify 修改列名称 数据类型 默认值等

<br><br>

# 2 索引创建、删除与使用：

## 1.1 create方式创建索引：
1. CREATE
2. [ UNIQUE -- 唯一索引
3. | FULLTEXT -- 全文索引
4. ] INDEX index_name ON table_name -- 不指定唯一或全文时默认普通索引
5. (column1[(length) [DESC|ASC]] [,column2,...]) -- 可以对多列建立组合索引 
<br>

## 1.2 alter方式创建索引：ALTER TABLE tb_name ADD [UNIQUE | FULLTEXT] [INDEX] index_content(content)
## 2.1 drop方式删除索引：DROP INDEX <索引名> ON <表名>
## 2.2 alter方式删除索引：ALTER TABLE <表名> DROP INDEX <索引名>
## 3.1 索引的使用：
- 索引使用时满足最左前缀匹配原则，即对于组合索引(col1, col2)，在不考虑引擎优化时，条件必须是col1在前col2在后，或者只使用col1，索引才会生效；
- 索引不包含有NULL值的列
- 一个查询只使用一次索引，where中如果使用了索引，order by就不会使用
- like做字段比较时只有前缀确定时才会使用索引
- 在列上进行运算后不会使用索引，如year(start_time)<2020不会使用start_time上的索引
<BR><BR>

### 在duration列创建普通索引idx_duration；
### 在exam_id列创建唯一性索引uniq_idx_exam_id；
### 在tag列创建全文索引full_idx_tag；

    create index idx_duration on examination_info(duration);
    create unique index uniq_idx_exam_id on examination_info (exam_id);
    create fulltext index full_idx_tag on examination_info(tag);

<BR><BR>

# SQL126 平均活跃天数和月活人数
### 筛选每个月的平均活跃天数和总活跃人数：
- 根据月份来选择时间。知识点：date_format() 通过这个函数匹配'%Y%m'年份和月份；
- 计算用户平均活跃天数：    
    - 根据不同的日期且不同的用户ID统计每个月用户的总活跃天数。知识点：distinct、count()、date_format()
    - 统计每个月用的总人数。知识点：distinct、count()
    - 总天数/总人数得到每个月的用户平均活跃天数；
- 计算每月总活跃人数，直接统计每月不同的用户id数。知识点：count()、distinct
### 按照月份分组group by date_format(submit_time, '%Y%m') 知识点：group by ...
### 保留两位小数。 知识点：round(x,2)
        select
            date_format (submit_time, '%Y%m') as month,
            round(
                (
                    count(distinct uid, date_format (submit_time, '%y%m%d'))
                ) / count(distinct uid),
                2
            ) as avg_active_days,
            count(distinct uid) as mau
        from
            exam_record
        where
            submit_time is not null
            and year (submit_time) = 2021
        group by
            date_format (submit_time, '%Y%m')
<BR><BR>

# SQL127 月总刷题数和日均刷题数

    select
        coalesce(year_mon, '2021汇总') as submit_month,
        count(question_id) as month_q_cnt,
        round(count(question_id) / max(t.days_month), 3) as avg_day_cnt
    from
        (
            select
                question_id,
                dayofmonth (last_day (submit_time)) as days_month,
                date_format (submit_time, '%Y%m') as year_mon
            from
                practice_record
            where
                year (submit_time) = 2021
        ) as t
    group by
        t.year_mon
    with
        rollup;

## **coalesce**
### COALESCE是一个函数，coalesce (expression_1, expression_2, ...,expression_n)依次参考各参数表达式，遇到非null值即停止并返回该值。

### SQL实例
    select coalesce(success_cnt, 1) from tableA
*当success_cnt 为null值的时候，将返回1，否则将返回success_cnt的真实值。*

    select coalesce(success_cnt,period,1) from tableA
*当success_cnt不为null，那么无论period是否为null，都将返回success_cnt的真实值（因为success_cnt是第一个参数），当success_cnt为null，而period不为null的时候，返回period的真实值。只有当success_cnt和period均为null的时候，将返回1。*

<BR><BR>

# SQL128 未完成试卷数大于1的有效用户
## 问题分解
- 关联作答记录和试卷信息：left join examination_info on using(exam_id)；（用left join和inner join效果一样）
- 筛选2021年的记录：where year(start_time)=2021
- 获取各用户的tag,start_time及未完成标记和已完成标记，如果该作答记录交卷了则已完成标记为1，未完成标记为0，否则相反：if(submit_time is null, 1, null) as incomplete
- 按用户分组：group by uid
- 统计未完成试卷作答数和已完成试卷作答数：count(incomplete) as incomplete_cnt
- 统计作答过的tag集合：
    -  对于每条作答tag，用:连接日期和tag：concat_ws(':', date(start_time), tag)
    - 对于一个人（组内）的多条作答，用;连接去重后的作答记录：group_concat(distinct concat_ws(':', date(start_time), tag) SEPARATOR ';')
- 筛选未完成试卷作答数大于1的有效用户：having complete_cnt >= 1 and incomplete_cnt BETWEEN 2 and 4
    - 完成试卷作答数至少为1：complete_cnt >= 1
    - 未完成数小于5：incomplete_cnt < 5
    - 未完成试卷作答数大于1：incomplete_cnt > 1

            SELECT uid, count(incomplete) as incomplete_cnt,
            count(complete) as complete_cnt,
            group_concat(distinct concat_ws(':', date(start_time), tag) SEPARATOR ';') as detail
            from (
                SELECT uid, tag, start_time,
                if(submit_time is null, 1, null) as incomplete,
                if(submit_time is null, null, 1) as complete
                from exam_record 
                left join examination_info using(exam_id)
                where year(start_time)=2021
                ) as exam_complete_rec
            group by uid
            having complete_cnt >= 1 and incomplete_cnt BETWEEN 2 and 4
            order by incomplete_cnt DESC; 
            
| uid | incomplete_cnt | complete_cnt | detail |
|:--------| :---------:|:---------:| :---------:|            
|1002|2|4|2021-09-01:算法;2021-07-02:SQL;2021-09-02:SQL;2021-09-05:SQL;2021-07-05:SQL|

			
<BR><BR>

# SQL129 月均完成试卷数不小于3的用户爱作答的类别


    select 
    tag,
    count(start_time) as tag_cnt
    from exam_record
    join examination_info using(exam_id)
    where uid in(
        #统计出“当月均完成试卷数”不小于3的用户们
        select
            uid
        from exam_record
        join examination_info using(exam_id)
        where submit_time is not null
        group by uid,month(start_time) having count(score)>=3
    )
    group by tag
    order by tag_cnt desc;
